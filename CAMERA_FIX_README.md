# Исправление воспроизведения RMB drag камеры

## Проблема
При воспроизведении макроса с движением камеры (RMB drag):
- Экран трясся/мерцал
- Камера оставалась на месте (не двигалась)
- Даже с ShiftLock камера не реагировала на движения мыши

## Корневая причина
Исходная логика имела фундаментальные ошибки в расчете дельты:
1. `rmb_center` обновлялся ПОСЛЕ каждого движения, вызывая накопление ошибок
2. Дельта рассчитывалась от движущейся цели вместо инкрементальных шагов
3. Это приводило к неправильной величине и направлению движений камеры

## Решение

### Ключевые изменения:

1. **Правильные инкрементальные дельты**: Использовать `last_mouse_pos` вместо `rmb_center` для расчета дельты
2. **Корректная инициализация**: Инициализировать `last_mouse_pos` при нажатии ПКМ для чистого старта
3. **Сохранение rmb_center**: Держать `rmb_center` как исходную точку нажатия, не обновлять во время движения
4. **Чистое управление состоянием**: Правильный сброс состояния камеры при отпускании ПКМ

### Измененный код:

```python
# При движении с ПКМ:
if last_mouse_pos is not None:
    dx = int((x - last_mouse_pos[0]) * CAMERA_GAIN)  # Инкрементально от ПРЕДЫДУЩЕЙ позиции
    dy = int((y - last_mouse_pos[1]) * CAMERA_GAIN)
    send_relative_line(dx, dy)
last_mouse_pos = (x, y)  # Обновляем для следующего инкрементального расчета
```

### Результат:
- ✅ Плавное движение камеры без тряски
- ✅ Точное воспроизведение направлений
- ✅ Правильная чувствительность (100% точность с CAMERA_GAIN = 1.0)
- ✅ Детальное логирование для отладки

## Конфигурация
- `CAMERA_GAIN = 1.0` (100% точность с правильной инкрементальной логикой)
- `MIN_STEP_THRESHOLD = 0` (разрешить субпиксельные движения для точности)
- `DEBUG_CAMERA_MOVEMENT = True` (детальное логирование для валидации)

## Тестирование
Запустите `python3 test_camera_logic.py` для проверки симуляции логики.